/*
 * boot.c - auto-generated by CHDK code_gen.
 */
#include "lolevel.h"
#include "platform.h"
#include "core.h"
#include "asmsafe.h" //For debug purpose, it is required to use ASM_SAFE macro

const char * const new_sa = &_end;

/* Our stuff */
extern long wrs_kernel_bss_start;
extern long wrs_kernel_bss_end;
extern void createHook (void *pNewTcb);
extern void deleteHook (void *pTcb);


void boot();

/* "relocated" functions */
void __attribute__((naked,noinline)) h_usrInit();
void __attribute__((naked,noinline)) h_usrKernelInit();
void __attribute__((naked,noinline)) h_usrRoot();
//debug use only
#define YELLOW_LED       0xC02200B0
void __attribute__((naked,noinline)) my_blinker(int n) {
    asm volatile (
      "            STMFD   SP!, {R0-R9,LR}\n"
);
    int i, j;
    for (j=0; j<n; j++)
    {
        *((volatile int *) YELLOW_LED) = 0x46; // Turn on LED
        for (i=0; i<0x200000; i++) { asm volatile ( "nop \n" ); }

        *((volatile int *) YELLOW_LED) = 0x44; // Turn off LED
        for (i=0; i<0x400000; i++) { asm volatile ( "nop \n" ); }
    }
    for (i=0; i<0x900000; i++) { asm volatile ( "nop \n" ); }
    asm volatile (
      "            LDMFD   SP!, {R0-R9,PC}\n"
    );
}
//end debug
void boot()
{
    // All the asm code below is from: 0xff8100fc

    long *canon_data_src = (void*)0xffc33020;
    long *canon_data_dst = (void*)0x1900;
    long canon_data_len = 0x18c70 - 0x1900;
    long *canon_bss_start = (void*)0x18c70;
    long canon_bss_len = 0xc5d80 - 0x18c70;

    long i;

    // @ 0xff8100fc:
    asm volatile (
    "MRC     p15, 0, R0,c1,c0\n"
    "ORR     R0, R0, #0x1000\n"
    "ORR     R0, R0, #4\n"
    "ORR     R0, R0, #1\n"
    "MCR     p15, 0, R0,c1,c0\n"
    :::"r0");

    for(i=0;i<canon_data_len/4;i++)
    canon_data_dst[i]=canon_data_src[i];

    for(i=0;i<canon_bss_len/4;i++)
    canon_bss_start[i]=0;

    // @ 0xff8101cc:
    asm volatile (
    "MRC     p15, 0, R0,c1,c0\n"
    "ORR     R0, R0, #0x1000\n"
    "BIC     R0, R0, #4\n"
    "ORR     R0, R0, #1\n"
    "MCR     p15, 0, R0,c1,c0\n"
    :::"r0");

    h_usrInit();
}

/*************************************************************/
//** h_usrInit @ 0xFF813F04 - 0xFF813F3C, length=15
void __attribute__((naked,noinline)) h_usrInit() {
asm volatile (
"    MOV     R12, SP \n"
"    STMFD   SP!, {R11,R12,LR,PC} \n"
"    SUB     R11, R12, #4 \n"
"    SUB     SP, SP, #4 \n"
"    STR     R0, [R11, #-0x10] \n"
"    LDR     R0, [R11, #-0x10] \n"
"    BL      sub_FF813ED0 \n"
"    MOV     R0, #1 \n"
"    MOV     R1, #2 \n"
"    BL      sub_FFC15DCC \n"
"    BL      sub_FFBB4890 \n"
"    BL      sub_FF811EA4 \n"
"    BL      sub_FF813B34 \n"
"    BL      h_usrKernelInit \n"  // --> Patched. Old value = 0xFF813B5C.
"    LDMDB   R11, {R11,SP,PC} \n"
);
}

/*************************************************************/
//** h_usrKernelInit @ 0xFF813B5C - 0xFF813BD8, length=32
void __attribute__((naked,noinline)) h_usrKernelInit() {
asm volatile (
"    MOV     R12, SP \n"
"    STMFD   SP!, {R11,R12,LR,PC} \n"
"    SUB     R11, R12, #4 \n"
"    SUB     SP, SP, #8 \n"
"    BL      sub_FFC162CC \n"
"    BL      sub_FFC2C2D0 \n"
"    LDR     R3, =0x17A94 \n"
"    LDR     R0, =0xC5740 \n"
"    LDR     R1, [R3] \n"
"    LDR     R2, =0xBBC00 \n"
"    MOV     R3, #0x100 \n"
"    BL      sub_FFC24A4C \n"
"    LDR     R3, =0x17A54 \n"
"    LDR     R0, =0x18214 \n"
"    LDR     R1, [R3] \n"
"    BL      sub_FFC24A4C \n"
"    LDR     R3, =0x17B10 \n"
"    LDR     R0, =0xC5714 \n"
"    LDR     R1, [R3] \n"
"    BL      sub_FFC24A4C \n"
"    BL      sub_FFC30E50 \n"
"    BL      sub_FF811FE4 \n"
"    MOV     R3, R0 \n"
"    MOV     R2, #0x800 \n"
"    STR     R2, [SP] \n"
"    MOV     R2, #0 \n"
"    STR     R2, [SP, #4] \n"
"    LDR     R0, =h_usrRoot \n"  // --> Patched. Old value = 0xFF814170.
"    MOV     R1, #0x4000 \n"
//"  LDR     R2, =0xC5D80 \n"  // MEMISOSTART
"    LDR     R2, =new_sa\n"   // +
"    LDR     R2, [R2]\n"      // +
"    BL      sub_FFC28E3C \n"
"    LDMDB   R11, {R11,SP,PC} \n"
);
}

/*************************************************************/
//** h_usrRoot @ 0xFF814170 - 0xFF8141D0, length=25
void __attribute__((naked,noinline)) h_usrRoot() {
asm volatile (
"    MOV     R12, SP \n"
"    STMFD   SP!, {R11,R12,LR,PC} \n"
"    SUB     R11, R12, #4 \n"
"    SUB     SP, SP, #8 \n"
"    STR     R0, [R11, #-0x10] \n"
"    STR     R1, [R11, #-0x14] \n"
"    BL      sub_FF8140B0 \n"
"    LDR     R0, [R11, #-0x10] \n"
"    LDR     R1, [R11, #-0x14] \n"
"    BL      sub_FFC1C448 \n"
"    LDR     R0, [R11, #-0x10] \n"
"    LDR     R1, [R11, #-0x14] \n"
"    BL      sub_FFC1CEC0 \n"
"    BL      sub_FF813C00 \n"
"    BL      sub_FF813B08 \n"
"    MOV     R0, #0x32 \n"
"    BL      sub_FFC1F444 \n"
"    BL      sub_FF814104 \n"
"    BL      sub_FF8140DC \n"
"    BL      sub_FF814138 \n"
"    BL      sub_FF814050 \n"
"    BL      sub_FFC1ED04 \n"
"    BL      sub_FF81409C \n"
);

    _taskCreateHookAdd(createHook);
    _taskDeleteHookAdd(deleteHook);

    drv_self_hide();

// Return from subroutine
asm volatile (
"    BL      sub_FF812130 \n"
"    LDMDB   R11, {R11,SP,PC} \n"
);
}
